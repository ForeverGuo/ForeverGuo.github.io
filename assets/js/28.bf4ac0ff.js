(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{607:function(v,_,r){"use strict";r.r(_);var t=r(7),p=Object(t.a)({},(function(){var v=this,_=v.$createElement,r=v._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[r("h3",{attrs:{id:"ipc-rpc-lpc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#ipc-rpc-lpc"}},[v._v("#")]),v._v(" ipc rpc lpc")]),v._v(" "),r("p",[v._v("进程通信就是ipc(Inter-Process Communication), 两个进程可能是一台计算机的，也可能网络上的不同计算机的进程，所以进程通信方式分为两种：")]),v._v(" "),r("ul",[r("li",[v._v("本地过程调用LPC(local precedure call)")]),v._v(" "),r("li",[v._v("远程过程调用RPC(remote precedure call)")])]),v._v(" "),r("p",[v._v("本地过程调用就是信号量，管道，消息队列，共享内存的通信方式，但是如果是网络上的，那就要通过网络协议来通信了，比如 http，websocket。（可以了解下Http 与 RPC 的细节 ）"),r("br")]),v._v(" "),r("p",[v._v("对于大型企业来说，内部子系统较多，接口非常多的情况下，RPC框架的好处就显示出来了，首先是长链接，不必每次通信都要像HTTP一样去三次握手，减少网络开销。"),r("br"),v._v("\n其次就是RPC框架一般都有注册中心，有丰富的监控管理，发布，下线接口，动态扩展等，对调用方来说是无感知，统一化的操作。")]),v._v(" "),r("h3",{attrs:{id:"本地进程通信"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#本地进程通信"}},[v._v("#")]),v._v(" 本地进程通信")]),v._v(" "),r("ul",[r("li",[r("p",[v._v("信号量")]),v._v(" "),r("p",[v._v("如果是简单的标记，通过一个数字来表示，放在PCB（进程控制模块）的一个属性里，这叫做信号量，比如锁的实现就可以通过信号量。\n这种信号量的思想我们写前端代码经常用，比如实现节流的时候，也要加一个标记变量。")])]),v._v(" "),r("li",[r("p",[v._v("管道")]),v._v(" "),r("p",[v._v("信号量不能传递具体的数据，传递具体数据还得用别的方式。比如可以通过读写文件的方式来通信，这就是管道，如果是内存中的文件，叫做匿名管道，没有文件名，如果是真实的硬盘的文件，是有文件名的，叫做命名管道。"),r("br")]),v._v(" "),r("p",[v._v("文件需要先打开，然后再读和写，之后再关闭，这也是管道的特点。管道是基于文件的思想封装的，之所以叫管道，是因为只能一个进程读，一个进程写，是单向的（半双工）。需要目标进程同步的消费数据，不然就会阻塞住。"),r("br")]),v._v(" "),r("p",[v._v("这种管道的方式实现起来很简单，就是一个文件读写，但是只能用在两个进程之间通信，只能同步的通信。其实管道的同步通信也挺常见的，就是 stream 的 pipe方法。")])]),v._v(" "),r("li",[r("p",[v._v("消息队列")]),v._v(" "),r("p",[v._v("管道实现简单，但是同步的通信比较受限制，那如果想做成异步通信 ？ 加个队列做缓冲（buffer）不就行了，这就是消息队列。"),r("br")]),v._v(" "),r("p",[v._v("消息队列也是两个进程之间的通信，但是不是基于文件那一套思路，虽然也是单向的，但是有了一定的异步性，可以放很多消息，之后一次性消费。")])]),v._v(" "),r("li",[r("p",[v._v("共享内存")]),v._v(" "),r("p",[v._v("管道，消息队列都是两个进程间的，如果多个进程呢 ？"),r("br")]),v._v(" "),r("p",[v._v("可以通过申请一段多进程都可以操作的内存，叫做共享内存，用这种方式来通信。各进程都可以向该内存读写数据，效率比较高。"),r("br")]),v._v(" "),r("p",[v._v("共享内存虽然效率高，也能用于多进程的通信，但也不全是好处，因为多个进程可以读写，那么就很容易乱，要控制顺序，比如通过进程的信号量（标记变量）来控制。"),r("br")]),v._v(" "),r("p",[v._v("共享内村适用于多个进程之间的通信，不需要通过中间介质，所以效率更高。")])])])])}),[],!1,null,null,null);_.default=p.exports}}]);