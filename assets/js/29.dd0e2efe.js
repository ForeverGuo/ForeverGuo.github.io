(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{610:function(v,_,l){"use strict";l.r(_);var r=l(7),t=Object(r.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h3",{attrs:{id:"基础准备"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#基础准备"}},[v._v("#")]),v._v(" 基础准备")]),v._v(" "),l("ul",[l("li",[v._v("引用：内存的起始地址")]),v._v(" "),l("li",[v._v("弱引用：WeakMap WeakSet")]),v._v(" "),l("li",[v._v("垃圾： 无任何引用的对象")]),v._v(" "),l("li",[v._v("回收： 清空被垃圾占用的内存")]),v._v(" "),l("li",[v._v("垃圾回收区域：堆内存")]),v._v(" "),l("li",[v._v("发生时间：程序空闲时间【JS 单线程，当进行垃圾回收时，主线程是要停止工作的】")])]),v._v(" "),l("h3",{attrs:{id:"如何识别垃圾"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#如何识别垃圾"}},[v._v("#")]),v._v(" 如何识别垃圾")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("引用计数")]),v._v(" "),l("p",[v._v("优点："),l("br")]),v._v(" "),l("ol",[l("li",[v._v("引用计数收集器执行简单，实现简单，判定效率高，无延迟，对程序不被长时间打断的实时环境比较有利 "),l("br")]),v._v(" "),l("li",[v._v("即可回收垃圾：每个对象都有自己的计数器，一旦计数器为0立刻进行垃圾回收"),l("br")]),v._v(" "),l("li",[v._v("最大暂停时间短：因为垃圾的即时回收，会大幅缩减程序的暂停时间"),l("br")]),v._v(" "),l("li",[v._v("没必要沿指针查找：与标记清除算法不一样，没必要由根出发沿指针查找"),l("br")])]),v._v(" "),l("p",[v._v("缺点："),l("br")]),v._v(" "),l("ol",[l("li",[v._v("赋值时需要更新计数器，增加了微量时间开销，影响不大，最严重的问题是引用计数器无法处理循环引用的问题 "),l("br")]),v._v(" "),l("li",[v._v("计数器的增减比较繁重 "),l("br")]),v._v(" "),l("li",[v._v("计数器需要占用很多位 "),l("br")]),v._v(" "),l("li",[v._v("循环引用无法回收a引用b，b引用a，这种情况始终无法回收")])])]),v._v(" "),l("li",[l("p",[v._v("根搜索法")])])]),v._v(" "),l("h3",{attrs:{id:"v8的垃圾回收器"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#v8的垃圾回收器"}},[v._v("#")]),v._v(" V8的垃圾回收器")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("定期执行的基本任务")]),v._v(" "),l("ol",[l("li",[v._v("识别活跃对象/死对象")]),v._v(" "),l("li",[v._v("回收/重用死对象占用的内存")]),v._v(" "),l("li",[v._v("压缩/碎片整理内存")])])])]),v._v(" "),l("p",[v._v("这些任务可以按顺序执行，也可以任意交错执行。stop-the-world的方式暂停 JavaScript 执行并在主线程上按顺序执行这些任务，当然这种方式的副作用就是会导致主线程出现卡顿和延迟，用户感知明显【60Hz 16.7ms】"),l("br")]),v._v(" "),l("p",[v._v("free-list：记录清理出来的内存位置和大小，当有新的对象需要分配内存空间时，就会在free-list中查找")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("V8的堆内存区域划分")]),v._v(" "),l("p",[v._v("V8主要将堆内存划分为两个区域，新生代 与 老生代 "),l("br")]),v._v(" "),l("p",[v._v("新生代：生命周期很短，临时存在，需要的空间相对较小 【例如：执行环境上下文】 "),l("br"),v._v("\n老生代：生命周期较长，持久存在，需要的空间相对较大")])]),v._v(" "),l("li",[l("p",[v._v("针对老生代使用 Major GC，采用了Mark-compact 算法【标记-整理】来管理内存")]),v._v(" "),l("p",[v._v("Major GC 主要是为了 Mark-Sweep 算法所带来的内存缝隙而提出来的优化方案，标记方式依然通过根搜索算法进行标记，compact 整理算法主要是执行："),l("br")]),v._v(" "),l("ol",[l("li",[v._v("把存活的对象移动到该去的位置")]),v._v(" "),l("li",[v._v("修改引用，让他们指向新的地址")])])]),v._v(" "),l("li",[l("p",[v._v("新生代使用了 Minor GC (Scavenger)【深度优先遍历算法】 用于管理新生代内存，使用了一种名为 cheney 的 GC 复制算法，一种使用空间换时间的方法，因此，了解新生代内存空间到底是如何管理的，实际上是就需要对空间复制算法有深刻的理解")]),v._v(" "),l("ol",[l("li",[v._v("划分from 与 to 空间一样的内存，且 to 空间是 空的")]),v._v(" "),l("li",[v._v("根搜索算法找出活跃对象")]),v._v(" "),l("li",[v._v("将活跃对象复制到 to 空间，并且标记为已复制记号【再次复制的时候，可以区分是否已复制】")]),v._v(" "),l("li",[v._v("清空from 空间【因为全是死对象】，并且将 from 空间 改成 to 空间，to 空间改成 from 空间【即进行两个空间对调，恢复成开始的状态】")])]),v._v(" "),l("p",[v._v("缺点：深度递归可能导致当前栈空间占用，最终导致栈溢出情况")])]),v._v(" "),l("li",[l("p",[v._v("Cheney GC 【广度优先遍历算法，迭代方式】")]),v._v(" "),l("ol",[l("li",[v._v("将 to 空间模拟为一个队列，start = $scan, end = $free,")]),v._v(" "),l("li",[v._v("根搜索算法找到了就入队，找完了第一层，然后开始第二层，如果没有了，start指针向前走，并搜索下一个节点的内部循环")]),v._v(" "),l("li",[v._v("start 开始指针不断往前走，直到start 指针 与 end 指针相等 代表执行完毕")]),v._v(" "),l("li",[v._v("最后清空from 并与 to 空间互换")])])])]),v._v(" "),l("p",[l("font",{attrs:{color:"#e93011"}},[v._v("新生代中大多数对象都是用完即走的，生命周期很短，根搜索算法找到的永远是少数，复制的对象就很少，也是节省性能，空间换时间【性能的优化是有一定的前提条件】")])],1),v._v(" "),l("h3",{attrs:{id:"优化-orinoco"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#优化-orinoco"}},[v._v("#")]),v._v(" 优化 Orinoco")]),v._v(" "),l("p",[v._v("orinoco 为V8的垃圾回收器的项目代号，为了提升用户体验，解决全停顿问题，利用了增量标记，懒性清理，并发，并行来降低主线程挂起的时间")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("Incremental 增量 Concurrent 并发  Parallel 并行")]),v._v(" "),l("p",[v._v("增量执行：主线程间歇性的执行一部分工作，我们会将 GC 任务拆分成多个小任务，然后在主线程的间隙中执行这些小任务")]),v._v(" "),l("p",[v._v("当增量标记完成后，例如当前的可用内存足以让我们快速的执行代码，其实我们没有必要立即清理内存，可以将清理的过程延迟一下，让JavaScript逻辑代码先执行，也无需一次性的清理完所有的垃圾，而是按需逐步清理，直到所有的页面都清理完毕"),l("br")]),v._v(" "),l("p",[v._v("结合浏览器自带的任务调度的空闲时间Idle，增量标记与惰性清理的出现，使主线程的最大停顿时间减少了80%，页面更加流畅了")])]),v._v(" "),l("li",[l("p",[v._v("分代收集")]),v._v(" "),l("p",[v._v("将堆分为新生代与老生代，多回收新生代，少回收老生代，这样就减少了每次需遍历的对象，从而减少每次垃圾回收的耗时")])]),v._v(" "),l("li",[l("p",[v._v("增量收集")]),v._v(" "),l("p",[v._v("如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停，所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理，这样就解决了长时间停顿的问题")])]),v._v(" "),l("li",[l("p",[v._v("闲时收集")]),v._v(" "),l("p",[v._v("垃圾收集器只会在CPU空闲时尝试运行，以减少可能对代码执行的影响")])]),v._v(" "),l("li",[l("p",[v._v("启发优化手段")]),v._v(" "),l("ol",[l("li",[v._v("shaking 技术")]),v._v(" "),l("li",[v._v("减少闭包对象的大小，而非不使用闭包")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);