(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{612:function(s,e,o){"use strict";o.r(e);var i=o(7),v=Object(i.a)({},(function(){var s=this,e=s.$createElement,o=s._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[o("h3",{attrs:{id:"cookie"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cookie"}},[s._v("#")]),s._v(" Cookie")]),s._v(" "),o("p",[s._v("cookie 本站点章节中已有，自行查阅～")]),s._v(" "),o("h3",{attrs:{id:"session"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#session"}},[s._v("#")]),s._v(" Session")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("session 是另一种记录服务器和客户端会话状态的机制")])]),s._v(" "),o("li",[o("p",[s._v("session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie中")])]),s._v(" "),o("li",[o("p",[s._v("session 认证流程：")]),s._v(" "),o("ol",[o("li",[s._v("用户第一次请求服务器的时候，服务器根据用户提交的信息，创建对应的Session")]),s._v(" "),o("li",[s._v("请求返回时将此Session的唯一标识 SessionID 返回给浏览器")]),s._v(" "),o("li",[s._v("浏览器接收到服务器返回的SessionID 后，会将此信息存入到 Cookie 中，同时Cookie记录此SessionID 属于哪个域名")]),s._v(" "),o("li",[s._v("当用户第二次访问服务器的时候，请求会自动把此域名下的Cookie信息也发送给服务端，服务端会从Cookie中获取SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作")])]),s._v(" "),o("p",[s._v("根据以上流程可知，"),o("font",{attrs:{color:"#e93011"}},[s._v("SessionID 是连接 Cookie 和 Session 的一道桥梁，")]),s._v("大部分系统也是根据此原理来验证用户登录状态")],1)])]),s._v(" "),o("h3",{attrs:{id:"cookie-和-session-的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#cookie-和-session-的区别"}},[s._v("#")]),s._v(" Cookie 和 Session 的区别")]),s._v(" "),o("ul",[o("li",[s._v("安全性： Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie是存储在客户端的")]),s._v(" "),o("li",[s._v("存取值的类型不同： Cookie只支持字符串数据，Session 可以存任意数据类型")]),s._v(" "),o("li",[s._v("有效期不同：Cookie 可设置为长时间保存，比如经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效")]),s._v(" "),o("li",[s._v("存储大小不同：单个 Cookie 保存的数据不能超过4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源")])]),s._v(" "),o("h3",{attrs:{id:"token"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#token"}},[s._v("#")]),s._v(" Token")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("Access Token")]),s._v(" "),o("ol",[o("li",[s._v("访问资源接口（API）时所需要的资源凭证")]),s._v(" "),o("li",[s._v("简单 token 的组成：uid（用户唯一的身份标识），time（当前时间的时间戳），sign（签名，token的前几位以哈希算法压缩成的一定长度的十六进制字符串）")])])]),s._v(" "),o("li",[o("p",[s._v("服务器对Token的存储方式：")]),s._v(" "),o("ol",[o("li",[s._v("存到数据库中，每次客户端请求的时候取出来验证（服务端有状态）")]),s._v(" "),o("li",[s._v("存到redis中，设置过期时间，每次客户端请求的时候取出来验证（服务端有状态）")]),s._v(" "),o("li",[s._v("不存，每次客户端请求的时候根据之前的生成方法再生成一次来验证（JWT，服务端无状态）")])])]),s._v(" "),o("li",[o("p",[s._v("特点")]),s._v(" "),o("ol",[o("li",[s._v("服务端无状态化，可扩展性好")]),s._v(" "),o("li",[s._v("支持移动端设备")]),s._v(" "),o("li",[s._v("安全")]),s._v(" "),o("li",[s._v("支持跨程序调用")])])]),s._v(" "),o("li",[o("p",[s._v("token 的身份验证流程：")]),s._v(" "),o("ol",[o("li",[s._v("客户端使用用户名和密码请求登录")]),s._v(" "),o("li",[s._v("服务端收到请求，去验证用户名和密码")]),s._v(" "),o("li",[s._v("验证成功后，服务端会签发一个token并把这个token发送给客户端【将登录凭证做数字签名，加密后得到字符串作为token】")]),s._v(" "),o("li",[s._v("客户端收到token 以后，会把它存储起来，比如放在cookie里或者 localStorage 里")]),s._v(" "),o("li",[s._v("客户端每次向服务端请求资源的时候需要带着服务端签发的token")]),s._v(" "),o("li",[s._v("服务端收到请求后，然后去验证客户端请求里面带着的token，如果验证成功，就向客户端返回请求的数据")])]),s._v(" "),o("p",[o("font",{attrs:{color:"#e93011"}},[s._v("每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里")]),s._v(" "),o("br"),s._v(" "),o("font",{attrs:{color:"#e93011"}},[s._v("token 完全由应用管理，所以可以避开同源策略")])],1)])]),s._v(" "),o("p",[s._v("注意： 登录时 token 不宜保存在 localStorage，被 XSS 攻击时容易泄漏，所以比较好的方式是把 token 写在 cookie 里，为了保证 xss攻击时不被获取，还要设置 cookie 的 http-only，这样，我们就能确保js 读取不到cookie的信息了，再加上https，能让我们的请求更安全一些")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("Refresh Token")]),s._v(" "),o("ol",[o("li",[s._v("另外一种token --- refresh token")]),s._v(" "),o("li",[s._v("refresh token 是专用于刷新 access token 的token，如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名 和 密码，会很麻烦，有了refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作")]),s._v(" "),o("li",[s._v("Access Token的有效期比较短，当 Access Token 由于 过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录")]),s._v(" "),o("li",[s._v("Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Access Token 时才会验证，不会业务接口响应时间造成影响，也不需要 Session 一样一直保持在内存中以应对大量的请求")])])])]),s._v(" "),o("h3",{attrs:{id:"token-和-session的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#token-和-session的区别"}},[s._v("#")]),s._v(" Token 和 Session的区别")]),s._v(" "),o("ul",[o("li",[s._v("Session 是一种记录服务器和客户端会话状态的机制，是服务端有状态化，可以记录会话信息，而 Token 是令牌，访问资源接口（API）时所需要的资源凭证，Token 使服务端无状态化，不会存储会话信息")]),s._v(" "),o("li",[s._v("Session 和 Token 并不矛盾，作为身份认证 Token 安全性 比 Session 好，因为每一个请求都有签名还能防止监听以及重复攻击，而 Session 就必须依赖链路层 来保障通讯安全了，如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器保存一些状态")]),s._v(" "),o("li",[s._v("如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token")])]),s._v(" "),o("h3",{attrs:{id:"jwt"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#jwt"}},[s._v("#")]),s._v(" JWT")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("JSON Web Token（JWT）是目前最流行的跨域认证解决方案")])]),s._v(" "),o("li",[o("p",[s._v("是一种认证授权机制")])]),s._v(" "),o("li",[o("p",[s._v("JWT 是为了在网络应用环境间传递声明而执行的一种基于JSON的开发标准，JWT的声明一般被用来在身份提供和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，比如用在用户登录上")])]),s._v(" "),o("li",[o("p",[s._v("可以使用HMAC算法或者是RSA的公/私密钥对 JWT 进行签名，因为数字签名的存在，这些传递的信息是可信的")])]),s._v(" "),o("li",[o("p",[s._v("JWT 的组成：Header（头部).Payload（负载).Signature（签名）")])]),s._v(" "),o("li",[o("p",[s._v("JWT 认证流程")]),s._v(" "),o("ol",[o("li",[s._v("用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT")]),s._v(" "),o("li",[s._v("客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）")]),s._v(" "),o("li",[s._v("当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT")])]),s._v(" "),o("div",{staticClass:"language-js line-numbers-mode"},[o("pre",{pre:!0,attrs:{class:"language-js"}},[o("code",[s._v("Authorization"),o("span",{pre:!0,attrs:{class:"token operator"}},[s._v(":")]),s._v(" Bearer "),o("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("token"),o("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])]),s._v(" "),o("div",{staticClass:"line-numbers-wrapper"},[o("span",{staticClass:"line-number"},[s._v("1")]),o("br")])]),o("ol",{attrs:{start:"4"}},[o("li",[s._v("服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为")]),s._v(" "),o("li",[s._v("因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要")]),s._v(" "),o("li",[s._v("因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）")]),s._v(" "),o("li",[s._v("因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制，也节省了内存消耗")]),s._v(" "),o("li",[s._v("JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。")])])])]),s._v(" "),o("h3",{attrs:{id:"token-和-jwt-的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#token-和-jwt-的区别"}},[s._v("#")]),s._v(" Token 和 JWT 的区别")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("都是访问资源的令牌")])]),s._v(" "),o("li",[o("p",[s._v("都可以记录用户信息")])]),s._v(" "),o("li",[o("p",[s._v("都是使服务端无状态化")])]),s._v(" "),o("li",[o("p",[s._v("都是只有验证成功后，客户端才能访问服务端上受保护的资源")])]),s._v(" "),o("li",[o("p",[s._v("token： 服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效")])]),s._v(" "),o("li",[o("p",[s._v("JWT：将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据")])])]),s._v(" "),o("h3",{attrs:{id:"分布式架构下-session-共享方案"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#分布式架构下-session-共享方案"}},[s._v("#")]),s._v(" 分布式架构下 session 共享方案")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("session 复制")]),s._v(" "),o("p",[s._v("任何一个服务器上的session发生改变（增删改），该节点会把这个session的所有内容序列化，然后广播给所有其他节点，不管其他服务器需不需要session，以此来保证session同步 "),o("br")])])]),s._v(" "),o("p",[s._v("优点： 可容错，各个服务器间 session 能够实时响应"),o("br"),s._v("\n缺点； 会对网络负荷造成一定压力，如果session量大的话可能会造成网络阻塞，拖慢服务器性能")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("粘性 session/IP 绑定策略")]),s._v(" "),o("p",[s._v("采用 Nginx 中的 ip_hash 机制，将某个ip的所有请求都定向到同一台服务器上，即将用户和服务器绑定，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘性到了一块，这就是粘性session机制")])])]),s._v(" "),o("p",[s._v("优点： 简单，不需要对session做任何处理"),o("br"),s._v("\n缺点： 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效"),o("br"),s._v("\n适用场景：发生故障对客户产生的影响较小，服务器发生故障是低概率事件"),o("br"),s._v("\n实现方式：以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session")]),s._v(" "),o("ul",[o("li",[o("p",[s._v("session 共享（常用）")]),s._v(" "),o("p",[s._v("使用分布式缓存方案比如 Memcached，Redis 来缓存 session，但是要求 Memcached 或 Redis 必须集群"),o("br"),s._v("\n把session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次Redis，但是这种方案带来的好处也是很大的："),o("br"),s._v("\n= 实现了session共享"),o("br"),s._v("\n= 可以水平扩展（增加Redis服务器）"),o("br"),s._v("\n= 服务器重启 session 不丢失（不过也要注意 session 在 Redis中的刷新/失效机制）"),o("br"),s._v("\n= 不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和APP端）")])]),s._v(" "),o("li",[o("p",[s._v("session 持久化")]),s._v(" "),o("p",[s._v("将session存储到数据库中，保证session的持久化"),o("br")])])]),s._v(" "),o("p",[s._v("优点：服务器出现问题，session 不会丢失"),o("br"),s._v("\n缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库")]),s._v(" "),o("h3",{attrs:{id:"只要关闭浏览器-session-真的就消失了"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#只要关闭浏览器-session-真的就消失了"}},[s._v("#")]),s._v(" 只要关闭浏览器，session 真的就消失了 ？")]),s._v(" "),o("ul",[o("li",[s._v("除非程序通知服务器删除session，程序一般都是在用户做login off 的时候发个指令去删除session")]),s._v(" "),o("li",[s._v("大部分 session 机制都使用会话 cookie 来保存 session id")]),s._v(" "),o("li",[s._v("服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把session 删除 以节省存储空间")])])])}),[],!1,null,null,null);e.default=v.exports}}]);